<head>
    <style> body { margin: 0; } </style>
  
    <script src="//unpkg.com/3d-force-graph"></script>
    <script src="//unpkg.com/three"></script>
    <script src="//unpkg.com/three-spritetext"></script>
    <!--<script src="../../dist/3d-force-graph.js"></script>-->
    <link rel="stylesheet" href="viz/style.css">
  </head>
  
  <body>
    
    <div id="3d-graph"></div>
    <div class="dimensions-selector">
        <input type="radio" name="color_radio" id='Standard' checked> Reached
        <input type="radio" name="color_radio" id='Techno'> Techno
        <input type="radio" name="color_radio" id='Flux'> Flux
        <input type="radio" name="color_radio" id='Temp'> Temp
        <input type="radio" name="color_radio" id='Gravity'> Gravity
        <input type="radio" name="color_radio" id='Biome'> Biome
        <input type="radio" name="color_radio" id='Pop'> Pop density
        <input type="radio" name="color_radio" id='Inh'> Inhabitants
        <input type="radio" name="color_radio" id='Reaction'> Social
    </div>
    <div class="graph-data">
        <span id="graph-data-description"></span>
    </div>


    <script type="module">
      import { UnrealBloomPass } from '//unpkg.com/three/examples/jsm/postprocessing/UnrealBloomPass.js';
      // import { AfterimagePass  } from '//unpkg.com/three/examples/jsm/postprocessing/AfterimagePass.js';
      const elem = document.getElementById('3d-graph');



      const pathNodes = new Set();
      const hpathNodes = new Set();
      const highlightNodes = new Set();
      let hoverNode = null;
      let rclickedNode = null;
      let scale_factor = 1;
      let node_color_filter = "Standard"
      
      function node_color(node){
        if(node_color_filter != "Standard") {
          let color = node[node_color_filter];
          return color;
        }

        if(node.id == 0) return '#FFDD33';
        
        if (hoverNode) {
          if (hoverNode.id == node.id) return '#FF11AA';
          else if (pathNodes.has(node.id)) return '#11DD11';
          else if (highlightNodes.has(node.id)) return '#FF3333';
        }
        if (node.reached == 1) {
          return '#ede68a';
        }

        return '#222831';
      }

      if (document.querySelector('input[name="color_radio"]')) {
        document.querySelectorAll('input[name="color_radio"]').forEach((elem) => {
          elem.addEventListener("change", function(event) {
            node_color_filter = event.target.id;
            updateHighlight();
          });
        });
      }

      function node_opacity(node){
        if(node.id == 0) return 1;
        
        if (hoverNode) {
          if (hoverNode.id == node.id) return 1;
          else if (pathNodes.has(node.id)) return 1;
          else if (highlightNodes.has(node.id)) return 1;
        }
        if (node.reached == 1) {
          return 1;
        }

        return 0.6;
      }

      function node_size(node){
        return scale_factor * (node.reached == 1 ? (node.id == 0 ? 30 : 4) : 2);
      }

      const Graph = ForceGraph3D()(elem)
        .jsonUrl('viz/multivers.json')
        .nodeColor(node => {
          return node_color(node);
        })
        .nodeThreeObjectExtend(true)
        .nodeThreeObject(node => {
          if(rclickedNode) {
            if (!( highlightNodes.has(node.id)
                  || node.neighbors.some((neigh)=>highlightNodes.has(neigh))
                  || hpathNodes.has(node.id) 
                  || pathNodes.has(node.id))) {
                    return null;
                  }
                  
          }
          if(node.reached == 0 && !rclickedNode) return null;

          const sprite = new SpriteText(`${node.name}` + '\n\n\n');
          sprite.color = 'lightgrey';
          sprite.textHeight = 9;
          return sprite;
        })
        // .nodeThreeObject((node) => 
        //   new THREE.Mesh(new THREE.SphereGeometry(node_size(node)),
        //           new THREE.MeshLambertMaterial({
        //             color: node_color(node),
        //             transparent: true,
        //             opacity: 0.75
        //           })))

        .linkColor(link => {
          if (hoverNode) {
            if ((pathNodes.has(link.source.id) && pathNodes.has(link.target.id))) {
              if (link.unreached == 0) 
                return "#77FFAA";
              return "#11DD11";
            } else if (hoverNode.id == link.source.id || hoverNode.id == link.target.id) {
              return link.unreached == 1 ? '#AA0000' : '#FF2222';
            } else if((hpathNodes.has(link.source.id) && hpathNodes.has(link.target.id)))
              return "#DD55DD";
          }
          return link.unreached == 1 ? '#23103A' : ( (node_color_filter != "Standard") ? '#333333' : '#14ffec');         
        })

        .linkVisibility(link => {
          if(rclickedNode != null) {
            if(highlightNodes.has(link.source.id) && hoverNode.id == link.target.id)
              return true;
            if(highlightNodes.has(link.target.id) && hoverNode.id == link.source.id)
              return true;      
            
            if(rclickedNode.neighbors.includes(link.target.id) || rclickedNode.neighbors.includes(link.source.id))
              return true;
            
            if((pathNodes.has(link.source.id) && pathNodes.has(link.target.id)))
              return true;

            // for (let i = 1; i < hpathNodes.length; i++) {
            //   if(link.source.id == hpathNodes[i-1] && link.target.id == hpathNodes[i])            
            //     return true;
            //   if(link.source.id == hpathNodes[i] && link.target.id == hpathNodes[i-1])            
            //     return true;
            // }
            if((hpathNodes.has(link.source.id) && hpathNodes.has(link.target.id)))
              return true;
            return false;
          }

          if(link.unreached == 1) {
            if(highlightNodes.has(link.source.id) && hoverNode.id == link.target.id)
              return true;
            if(highlightNodes.has(link.target.id) && hoverNode.id == link.source.id)
              return true;  
            if((pathNodes.has(link.source.id) && pathNodes.has(link.target.id)))
              return true;
            return false;  
          } 
          
          return true;
        })
        .nodeVisibility(node => {
          if(rclickedNode != null) {
            return highlightNodes.has(node.id)
                  || node.neighbors.some((neigh)=>highlightNodes.has(neigh))
                  || hpathNodes.has(node.id) 
                  || pathNodes.has(node.id);
            // return node.neighbors.some((neigh)=>highlightNodes.has(neigh))
            //       || node.neighbors.some((neigh)=>pathNodes.has(neigh))
            //       || highlightNodes.has(node.id) 
            //       || hpathNodes.has(node.id) 
            //       || pathNodes.has(node.id);
          }
          return true;
        })
        .nodeVal(node => scale_factor * (node.reached == 1 ? (node.id == 0 ? 30 : 4) : 2))
        // .nodeOpacity(node => node.unreached == 1 ? 0.3 : 0.6)
        .nodeLabel(node => `${node.name}`)
        .onNodeHover(node => {
          if ((!node && !highlightNodes.size) || (node && hoverNode === node)) return;

          elem.style.cursor = node ? 'pointer' : null
          if(!rclickedNode) {
            
            focus_on(node)
          }
        })
        .onNodeClick( (node, event) => {
          if (node == rclickedNode)
            rclickedNode = null;
          else
            rclickedNode = node;

          focus_on(node);
        })
        .linkOpacity(1)
        .linkWidth(link => scale_factor *  (link.unreached == 1 ? 0.75 : 1.5))
        .nodeOpacity(1)
        .linkDirectionalParticles((link)=> link.unreached == 1 ? 0 : 3)
        .linkDirectionalParticleSpeed(0.01)
        .linkDirectionalParticleWidth(scale_factor * 5)
        .linkDirectionalParticleColor("#FFFFFF")
        .onNodeRightClick(node =>{ 
          // console.log(node)
          // Aim at node from outside it
          const distance = 300;
          const distRatio = 1 + distance/Math.hypot(node.x, node.y, node.z);

          Graph.cameraPosition(
            { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio }, // new position
            node, // lookAt ({ x, y, z })
            2000  // ms transition duration
          );
        
        })//window.open(`https://bl.ocks.org/${node.user}/${node.id}`, '_blank'));
        .onLinkClick(link => console.log(link));

        function get_txt(node) {
          var txt = "<h2><b>" + node.name + "</b></h2>";
          txt += "<p style='text-align:left'>";
          for (let key in node.planet) {
            txt += "<b>" + key + "</b>:  " + node.planet[key] + "<br>";
          }
          txt += "</p>";
          return txt;
        }

        function focus_on(node) {
          highlightNodes.clear();
          pathNodes.clear();
          hpathNodes.clear();
          if (node) {
            highlightNodes.add(node.id);
            node.neighbors.forEach(neighbor => highlightNodes.add(neighbor));
            node.s_path.forEach(n => pathNodes.add(n));
            // node.h_path.forEach(n => hpathNodes.add(n));
            node.hs_path.forEach(n => hpathNodes.add(n));
            document.getElementById('graph-data-description').innerHTML = get_txt(node);
          }
          hoverNode = node || null;
          updateHighlight();
        }

        const bloomPass = new UnrealBloomPass();
        bloomPass.strength = 1.5;
        bloomPass.radius = 0.4;
        bloomPass.threshold = 0.2;
        Graph.postProcessingComposer().addPass(bloomPass);
              
        
        // const loader = new THREE.CubeTextureLoader();
        // const texture = loader.load([
        //   'viz/sky_neg_x.jpg',
        //   'viz/sky_pos_x.jpg',
        //   'viz/sky_pos_y.jpg',
        //   'viz/sky_neg_y.jpg',
        //   'viz/sky_neg_z.jpg',
        //   'viz/sky_pos_z.jpg',
        // ]);
        // Graph.scene().background = texture;



        function updateHighlight() {
          Graph
            .nodeColor(Graph.nodeColor())
            .linkWidth(Graph.linkWidth())
            .linkDirectionalParticles(Graph.linkDirectionalParticles());
        }


    </script>
  </body>